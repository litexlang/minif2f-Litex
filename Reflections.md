# Reflections

## General Reflections

什么时候需要用到 py：就是需要py来循环地生成证明的时候：有时候一些证明 很冗长，重复度很高，这时候你用 py 来生成一个str，然后贴在那个地方，这样就不用写很多重复的证明，而且打印出来的时候很好看。有时候这甚至是必须的，比如遍历地处理一个证明一个什么东西

## amc12a_2015_p10

litex能证明1,3,9,27,81是81的因子，但不能它们是唯一的因子（因为litex暂时没for i in range(1, 82) 的遍历去证明的办法）解决办法包括

1. 调用py库来计算81的因子，默认我们调用的库是对的（好处：这样做任何题目就会很容易，而且打印出来的时候很好看，如果让ai做题就会让ai有严格性：它是碉调包的，用完包然后把输出的结果贴在原地，非常准确），这样哪怕是自然语言编程也会很准确

2. 我内部引入对自然数上面的所有整数的遍历的证明，即引入for i in range(1, 82) 这样的遍历的办法. 这样能求解出来特别多的题目

3. lean的写法是 example : 81.divisors = [1,3,9,27,81] := by decide 这里 by decide 是去计算 Nat.divisors 81 的值，Nat.divisors 81 的值是 [d for d in range(1..n) if d | n] 这样的。本质上它也是内置了for循环和know（即知道从1到81的整数，可以和range(1,82)一一对应

## mathd_algebra_13

这是很典型的 是且只是 的证明。可能用一个claim不太够

## imo_1964_p1_2

貌似要引入 range 这个关键词，range表示一个集合，这个集合里面的元素是自然数，这个集合里面的元素是 0 到 6 之间的自然数，比如 range(0, 7)。但是我不太确定？？

意义：比如我要说：比7小的自然数有且仅有 {0, 1, 2, 3, 4, 5, 6} ，或者说对任意n，比n小的自然数是 {0, 1, ... n -1} 但因为我整个匹配和替换体系不支持这种 长度不定（因n不定）的写法，所以不知道怎么在litex里表达相关结论。

我必须要内置一个功能特异的东西，比如range，这样才能表达上述的情况，range是一个集合

不懂呀，如果有 prove_in_range 了我还需要这个object形式的range吗？？